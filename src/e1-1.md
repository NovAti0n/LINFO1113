# E1.1 - Number representation

Ces exercices se focalisent sur la conversion de nombres décimaux en nombres binaires, ainsi que sur les erreurs que certaines représentations peuvent engendrer.

## Question 1 - Integer representation (1/2)

### Solution

```
00011011, 00110100, 10000001
```

### Explications

La représentation en *unsigned integer* (entier non-signé, donc naturel) est la plus simple à calculer. Il suffit de faire une division entière par deux sur le nombre, noter le reste et de continuer jusqu'à ce qu'on arrive à 0.

Avant de commencer les calculs, il est toujours important d'avoir en tête les valeurs maximales possibles pour une certaine représentation (cela permet d'éviter de devoir transformer le nombre pour rien). Dans le cas d'un *unsigned interger*, l'intervalle supportée est $[0; 2^\text{bits} - 1]$. Pour cet exercice qui se fait en 8 bits, le nombre maximal sera donc $2^8 - 1 = 255$.

::: warning Notation
Pour les résolutions ci-dessous, nous considérerons que $\newcommand{\git}{\mathbin{/\mkern-6mu/}}A \git B$ correspond à la division entière entre $A$ et $B$.
:::

Pour 27 :

$$\begin{align}
27 \git 2 &= 13 && \text{reste } 1\\
13 \git 2 &= 6&& \text{reste } 1\\
6 \git 2 &= 3&& \text{reste } 0\\
3 \git 2 &= 1&& \text{reste } 1\\
1 \git 2 &= 0&& \text{reste } 1
\end{align}$$

Pour avoir la réponse, il suffit de lire **du bas vers le haut** les différents restes et de combler les nombres manquants par des 0 que l'on rajoute à l'avant (La consigne demande d'encoder les nombres sur 8 bits, il faut donc avoir 8 chiffres au total étant donné qu'un chiffre prend un bit). On obtient donc $11011$ auquel on rajoute trois 0, ce qui donne $00011011$.

Pour 52 :

$$\begin{align}
52 \git 2 &= 26 && \text{reste } 0\\
26 \git 2 &= 13&& \text{reste } 0\\
13 \git 2 &= 6&& \text{reste } 1\\
6 \git 2 &= 3&& \text{reste } 0\\
3 \git 2 &= 1&& \text{reste } 1\\
1 \git 2 &= 0&& \text{reste } 1
\end{align}$$

On obtient donc $110100$ auquel on rajoute deux 0, ce qui donne $00110100$.

Pour 129 :

$$\begin{align}
129 \git 2 &= 64 && \text{reste } 1\\
64 \git 2 &= 32&& \text{reste } 0\\
32 \git 2 &= 16&& \text{reste } 0\\
16 \git 2 &= 8&& \text{reste } 0\\
8 \git 2 &= 4&& \text{reste } 0\\
4 \git 2 &= 2&& \text{reste } 0\\
2 \git 2 &= 1&& \text{reste } 0\\
1 \git 2 &= 0&& \text{reste } 1
\end{align}$$

On obtient donc $10000001$ qui comporte déjà 8 chiffres, on ne doit donc rien ajouter.


## Question 2 - Integer representation (2/2)

### Solution

```
11100101, 11001100, XXXXXXXX
```

### Explications

Pour représenter des entiers négatifs, on utilise la représentation en *signed integer* (entier signé). Celle-ci ne change pas la méthode pour les entiers positifs, mais introduit une manière d'encoder les entiers négatifs. Elle commence de la même façon que pour les entiers positifs, mais si le nombre est négatif, on inverse les bits et on ajoute 1.

L'intervalle supportée est $[-2^\text{bits}; 2^\text{bits} - 1]$. Pour cet exercice qui se fait en 8 bits, l'intervalle sera donc $[-2^7; -2^7 - 1] = [-128; 127]$

Pour -27 :

$$\begin{align}
27 \git 2 &= 13 && \text{reste } 1\\
13 \git 2 &= 6&& \text{reste } 1\\
6 \git 2 &= 3&& \text{reste } 0\\
3 \git 2 &= 1&& \text{reste } 1\\
1 \git 2 &= 0&& \text{reste } 1
\end{align}$$

On obtient donc $11011$ auquel on rajoute trois 0 à l'avant pour avoir les 8 chiffres demandés ($00011011$, même réponse qu'à l'exercice précédent, ce qui est logique vu que le début ne change pas). -27 étant négatif, on inverse les bits (les 0 deviennent des 1 et inversement). Cela donne $11100100$ auquel on doit rajouter 1. La réponse est donc $11100101$.

Pour -52 :

$$\begin{align}
52 \git 2 &= 26 && \text{reste } 0\\
26 \git 2 &= 13&& \text{reste } 0\\
13 \git 2 &= 6&& \text{reste } 1\\
6 \git 2 &= 3&& \text{reste } 0\\
3 \git 2 &= 1&& \text{reste } 1\\
1 \git 2 &= 0&& \text{reste } 1
\end{align}$$

On obtient donc $110100$ auquel on rajoute deux 0 ($00110100$). -52 étant négatif, on inverse les bits. Cela donne $11001011$ auquel on doit rajouter 1. La réponse est donc $11001100$

::: danger Attention
Si le dernier bit vaut déjà 1 (comme dans l'exemple précédent), il suffit de le changer en 0 et de se déplacer vers la gauche. On répète ce processus jusqu'à tomber sur un bit qui vaut 0. On le change alors en 1 et on s'arrête là.
:::

Pour -129, on se trouve en dehors de l'intervalle supportée. 8 bits ne seront donc pas suffisants pour représenter ce nombre. La réponse est donc `XXXXXXXX`.

## Question 3 - Decimal number representation (1/2)

### Solution

```
000100001101, 010000110110
```

### Explications

Pour les nombres à virgule, cela devient plus compliqué. La partie entière fonctionne de la même manière d'un entier (cf. les deux questions précédentes). Pour la partie décimale, on va appliquer la méthode décrite dans l'exemple ci-dessous.

Pour 33.6875, on commence par transformer 33 en binaire :

$$\begin{align}
33 \git 2 &= 16 && \text{reste } 1\\
16 \git 2 &= 8&& \text{reste } 0\\
8 \git 2 &= 4&& \text{reste } 0\\
4 \git 2 &= 2&& \text{reste } 0\\
2 \git 2 &= 1&& \text{reste } 0\\
1 \git 2 &= 0&& \text{reste } 1
\end{align}$$

On obtient $100001$. Pour la partie décimale, on va la multiplier par 2, noter la partie entière et recommencer le processus avec la partie décimale jusqu'à arriver à 1.

$$\begin{align}
0.6875 * 2 &= 1.375 && \text{on retient } 1\\
0.375 * 2 &= 0.75&& \text{on retient } 0\\
0.75 * 2 &= 1.5&& \text{on retient } 1\\
0.5 * 2 &= 1&& \text{on retient } 1
\end{align}$$

Pour avoir la réponse, il suffit de lire **du haut vers le bas** les différents chiffres retenus. La partie décimale s'écrira donc $1011$.

La consigne demande d'encoder tout cela sur 12 bits, avec un nombre précis de bits pour la partie décimale. Cela se fait facilement en rajoutant des 0 (à l'avant pour la partie entière et à l'arrière pour la partie décimale).
* Pour la première sous-question (3 bits), on a $12 - 3 = 9$ bits pour la partie entière : on rajoute donc trois 0 à l'avant, ce qui donne $000100001$. Pour la partie décimale, on a 3 bits de disponible alors que notre réponse a quatre chiffres. On va donc la tronquer, ce qui donne $101$. On colle les deux réponses bout à bout et on obtient $000100001101$.
* Pour la deuxième sous-question (5 bits), on a $12 - 5 = 7$ bits pour la partie entière : on rajoute donc un 0 à l'avant, ce qui donne $0100001$. Pour la partie décimale, on a 5 bits de disponibles alors que notre réponse a quatre chiffres. On va donc ajouter un 0 **à l'arrière**, ce qui donne $10110$. On colle les deux réponses bout à bout et on obtient $010000110110$.

## Question 4 - Decimal number representation (2/2)

### Solution

```
0100 0010 0000 0110 1100 0000 0000 0000
```

### Explications

Probablement l'exercice le plus compliqué, étant donné que la méthode pour convertir un nombre en *binary32* est assez longue. Nous allons directement faire un exemple et expliquer petit à petit les étapes effectuées.

Pour transformer 33.6875 en *binary32*, on commence par utiliser la méthode décrite à la [question précédente](#explications-2). On obtient le nombre $100001.1011$ (notez la présence du point pour séparer la partie entière de la partie décimale).

On bouge le point pour qu'il n'y ait qu'un seul bit devant lui en multipliant le nombre par une puissance de 2 (c'est le même principe qu'une notation scientifique en base 10). Dans ce cas précis, il faut avancer le point de 5 places pour obtenir $1.000011011$ : on sait donc que $1.000011011 = 2^5 * 100001.1011$.

On doit ensuite ajouter 127 à la puissance de 2 obtenue et le transformer en binaire sur 8 bits. Ici, on encode donc $5 + 127 = 132$, ce qui donne :

$$\begin{align}
132 \git 2 &= 66 && \text{reste } 0\\
66 \git 2 &= 33&& \text{reste } 0\\
33 \git 2 &= 16&& \text{reste } 1\\
16 \git 2 &= 8&& \text{reste } 0\\
8 \git 2 &= 4&& \text{reste } 0\\
4 \git 2 &= 2&& \text{reste } 0\\
2 \git 2 &= 1&& \text{reste } 0\\
1 \git 2 &= 0&& \text{reste } 1
\end{align}$$

On obtient $10000100$ qui est déjà sur 8 bits (s'il manque des chiffres, il faut rajouter des 0 à l'avant comme fait lors des exercices précédents).

Pour la partie décimale, il suffit de rajouter des 0 à l'arrière pour arriver à 23 bits. Pour l'instant, on a $000011011$ qui fait 9 bits de long, il manque donc 14 chiffres. La partie décimale est donc $00001101100000000000000$.

La réponse est obtenue en collant les deux nombres binaires et en ajoutant au début de ceux-ci un 0 si le nombre est positif et un 1 si le nombre est négatif. 33.6875 est positif, la réponse est donc $01000010000001101100000000000000$.

## Question 5 - Relative error of fixed-point representation

### Solution

```
7
```

### Explications

La méthode la plus simple consiste à suivre ce que l'indice nous dit, à savoir tester les différents *scaling factors* (bits disponibles pour la partie décimale. Un *scaling factor* de 8 octroie 8 bits à la partie décimale) et de voir à partir duquel l'erreur relative passe en dessous de 5%. Cela peut se faire à la main ou via un script Python. Étant donné que bien comprendre la méthode est important, nous allons détailler les calculs à la main.

0.1 est un nombre particulier. En effet, sa représentation en binaire est infinie. On peut se convaincre facilement de cela en appliquant la méthode de la [question 3](#explications-2) :

$$\begin{align}
0.1 * 2 &= 0.2 && \text{on retient } 0\\
0.2 * 2 &= 0.4&& \text{on retient } 0\\
0.4 * 2 &= 0.8&& \text{on retient } 0\\
0.8 * 2 &= 1.6&& \text{on retient } 1\\
0.6 * 2 &= 1.2&& \text{on retient } 1\\
0.2 * 2 &= 0.4&& \text{on retient } 0
\end{align}$$

On voit clairement qu'à partir d'un moment, on revient à 0.2. On sait donc que 0.1 sera représenté par une suite infinie de la séquence $0011$ pour sa partie décimale (0.1 = $0.00011001100110011...$ Les premiers chiffres ne respectent pas la séquence car il faut un 0 pour la partie entière et un autre 0 pour la première opération qu'on a effectuée, à savoir $0.1 * 2$, qui ne se répète pas dans la séquence).

Commençons dès lors les calculs en partant de $k = 4$ (étant donné que les trois premiers chiffres de la partie décimale sont des 0, on sait que cela donnera 0 en base 10 qui a une erreur relative de $|0 - 0.1| \div |0.1| = 1 = 100\%$).

Le nombre $0.0001$ vaut $0.0625$ en base 10. Le meilleur moyen pour trouver cela est de trouver à quelle place sont les 1 dans la partie décimale et de calculer :

$$\sum_{0}^\text{Nombre de 1} 2^{-\text{place du 1}}$$

Dans ce cas, il n'y a qu'un seul 1 à la quatrième place : $0.0001 = 2^{-4} = 0.625$. L'erreur relative est de $|0.0625 - 0.1| \div |0.1| = 0.375 = 37.5\%$.

Pour $k = 5$, on a le nombre $0.00011$ qui donne $2^{-4} + 2^{-5} = 0.09375$ en base 10. L'erreur relative est de $|0.09375 - 0.1| \div |0.1| = 0.0625 = 6.25\%$.

Pour $k = 6$ et $k = 7$, on rajoute juste des 0, ce qui ne modifie pas le nombre en base 10 obtenu ($0.000110_2 = 0.0001100_2 = 0.09375_{10}$). L'erreur relative est donc toujours de $6.25\%$.

Ce n'est seulement qu'a $k = 8$ que l'erreur relative passe en dessous des $5\%$. En effet, $0.00011001 = 2^{-4} + 2^{-5} + 2^{-8} = 0.09765625$. On observe alors une erreur de $|0.09765625 - 0.1| \div |0.1| = 0.0234375 = 2.34\%$.

Néanmoins, `8` n'est pas la réponse finale. C'est un des rares cas où la consigne semble erronée. La réponse attendue est `7`, à savoir le dernier $k$ avant que l'erreur soit inférieure à $5\%$ (si vous avez une explication, n'hésitez pas à [ouvrir une issue](https://github.com/NovAti0n/LINFO1113/issues/new) sur le [GitHub](https://github.com/NovAti0n/LINFO1113) de ce site).

## Question 6 - Order of operations

### Solution

```py:line-numbers
import numpy as np

def smart_sum(array):
    max_el = max(array)
    result = 0

    for i in array:
        if abs(i - max_el) < 1e-20: continue # Vérifie si i == max_el (On est obligé de faire cela à cause des erreurs d'arrondi)
        result += i 

    return result + max_el
```

### Explications

L'un des problèmes de travailler avec des représentations de nombres qui ne sont pas infinies, c'est que l'on peut facilement sortir des limites imposées et causer ce qu'on appelle un *overflow*. En Python, au lieu de faire crash le programme lorsqu'un *overflow* survient, la valeur est remplacée par l'infini. Cela peut causer certains problèmes de calculs, étant donné que des opérations basiques vont se faire absorber par l'infini (Par exemple, $\infty + 1 = \infty$ : le 1 n'a plus aucun impact sur le calcul).

Prenons un code que l'on écrirait normalement pour résoudre l'exercice qui nous est proposé, à savoir calculer une somme d'éléments dans un vecteur.

```py:line-numbers
import numpy as np

def smart_sum(array):
    result = 0

    for i in array:
        result += i

    return result
```

Cela fonctionne parfaitement pour $\begin{pmatrix}1 & 2 & 3\end{pmatrix}$, qui renvoie alors 6. Les choses se compliquent lorsque l'on est en présence de très grands nombres, comme dans le vecteur $\begin{pmatrix}10^{16} & 1 & 1\end{pmatrix}$ qui renvoie... $10^{16}$. La raison pour laquelle cela se produit peut paraître évidente après avoir fait les exercices précédents : il y a un problème de précision.

Sans rentrer trop dans les détails, les nombres dans les vecteurs Numpy sont représentés soit en *float32* ou en *float64*, dépendamment de l'architecture de la machine. Prenons le cas du *float64*, étant donné que la plupart des ordinateurs de nos jours utilisent une architecture 64 bits.

Prenons un vecteur simple $\begin{pmatrix}10^{16} & 1\end{pmatrix}$ et représentons les deux nombres en *float64*.

$10^{16}$ peut être représenté comme :

$$(1 + 0.1110011001111001100110011001100110011001100110011010) * 2^{(66 - 1023)}$$

1 peut être représenté comme :

$$(1 + 0.0000000000000000000000000000000000000000000000000000) * 2^{(0 - 1023)}$$

Si on les additionne, on obtient :

$$(1 + 0.11100110011110011001100110011001100110011001100110101) * 2^{(66 - 1023)}$$

La partie décimale possède désormais plus de 52 bits (qui est le nombre de bits réservé en *float64*), elle doit donc être tronquée ou arrondie. En Python, la décision a été de l'arrondir vers le nombre pair le plus proche. On obtient donc :

$$(1 + 0.1110011001111001100110011001100110011001100110011010) * 2^{(66 - 1023)}$$

Si vous avez l'œil, vous remarquerez que c'est l'exacte notation de $10^{16}$. Le 1 n'a eu aucun impact sur le calcul : il a été absorbé par $10^{16}$.

Une manière de résoudre ce problème est d'additionner séparément les petits nombres et de rajouter le grand nombre à la fin. Cela permet d'utiliser ce mécanisme d'arrondi à notre avantage. C'est exactement ce qui est fait dans la solution proposée.

::: danger Attention
Faire cela ne change en rien la perte de précision, l'addition donnera un nombre qui a une partie décimale de plus de 52 bits. Elle sera juste tronquée à notre avantage, nous donnant ainsi la bonne réponse. Vous remarquerez par exemple que cette fonction ne donnera pas la bonne réponse pour le vecteur $\begin{pmatrix}10^{16} & 1 & 0\end{pmatrix}$ par exemple. L'erreur d'arrondi est toujours présente, elle a juste été décalée. Une manière plus précise et efficace de faire ce calcul est d'utiliser la [fonction `fsum`](https://docs.python.org/3/library/math.html#math.fsum) du module `math` qui a été spécialement créée pour cette utilisation, au détriment de la vitesse de calcul.
:::