# E1.1 - Number representation

Ces exercices se focalisent sur la conversion de nombres décimaux en nombres binaires, ainsi que sur les erreurs que certaines représentations peuvent engendrer.

## Question 1 - Integer representation (1/2)

### Solution

```
00011011, 00110100, 10000001
```

### Explications

La représentation en *unsigned integer* (entier non-signé, donc naturel) est la plus simple à calculer. Il suffit de faire une division entière par deux sur le nombre, noter le reste et de continuer jusqu'à ce qu'on arrive à 0.

Avant de commencer les calculs, il est toujours important d'avoir en tête les valeurs maximales possibles pour une certaine représentation (cela permet d'éviter de devoir transformer le nombre pour rien). Dans le cas d'un *unsigned interger*, l'intervalle supportée est $[0; 2^\text{bits} - 1]$. Pour cet exercice qui se fait en 8 bits, le nombre maximal sera donc $2^8 - 1 = 255$.

::: warning Notation
Pour les résolutions ci-dessous, nous considérerons que $\newcommand{\git}{\mathbin{/\mkern-6mu/}}A \git B$ correspond à la division entière entre $A$ et $B$.
:::

Pour 27 :

$$\begin{align}
27 \git 2 &= 13 && \text{reste } 1\\
13 \git 2 &= 6&& \text{reste } 1\\
6 \git 2 &= 3&& \text{reste } 0\\
3 \git 2 &= 1&& \text{reste } 1\\
1 \git 2 &= 0&& \text{reste } 1
\end{align}$$

Pour avoir la réponse, il suffit de lire **du bas vers le haut** les différents restes et de combler les nombres manquants par des 0 que l'on rajoute à l'avant (La consigne demande d'encoder les nombres sur 8 bits, il faut donc avoir 8 chiffres au total étant donné qu'un chiffre prend un bit). On obtient donc $11011$ auquel on rajoute trois 0, ce qui donne $00011011$.

Pour 52 :

$$\begin{align}
52 \git 2 &= 26 && \text{reste } 0\\
26 \git 2 &= 13&& \text{reste } 0\\
13 \git 2 &= 6&& \text{reste } 1\\
6 \git 2 &= 3&& \text{reste } 0\\
3 \git 2 &= 1&& \text{reste } 1\\
1 \git 2 &= 0&& \text{reste } 1
\end{align}$$

On obtient donc $110100$ auquel on rajoute deux 0, ce qui donne $00110100$.

Pour 129 :

$$\begin{align}
129 \git 2 &= 64 && \text{reste } 1\\
64 \git 2 &= 32&& \text{reste } 0\\
32 \git 2 &= 16&& \text{reste } 0\\
16 \git 2 &= 8&& \text{reste } 0\\
8 \git 2 &= 4&& \text{reste } 0\\
4 \git 2 &= 2&& \text{reste } 0\\
2 \git 2 &= 1&& \text{reste } 0\\
1 \git 2 &= 0&& \text{reste } 1
\end{align}$$

On obtient donc $10000001$ qui comporte déjà 8 chiffres, on ne doit donc rien ajouter.


## Question 2 - Integer representation (2/2)

### Solution

```
11100101, 11001100, XXXXXXXX
```

### Explications

Pour représenter des entiers négatifs, on utilise la représentation en *signed integer* (entier signé). Celle-ci ne change pas la méthode pour les entiers positifs, mais introduit une manière d'encoder les entiers négatifs. Elle commence de la même façon que pour les entiers positifs, mais si le nombre est négatif, on inverse les bits et on ajoute 1.

L'intervalle supportée est $[-2^\text{bits}; 2^\text{bits} - 1]$. Pour cet exercice qui se fait en 8 bits, l'intervalle sera donc $[-2^7; -2^7 - 1] = [-128; 127]$

Pour -27 :

$$\begin{align}
27 \git 2 &= 13 && \text{reste } 1\\
13 \git 2 &= 6&& \text{reste } 1\\
6 \git 2 &= 3&& \text{reste } 0\\
3 \git 2 &= 1&& \text{reste } 1\\
1 \git 2 &= 0&& \text{reste } 1
\end{align}$$

On obtient donc $11011$ auquel on rajoute trois 0 à l'avant pour avoir les 8 chiffres demandés ($00011011$, même réponse qu'à l'exercice précédent, ce qui est logique vu que le début ne change pas). -27 étant négatif, on inverse les bits (les 0 deviennent des 1 et inversement). Cela donne $11100100$ auquel on doit rajouter 1. La réponse est donc $11100101$.

Pour -52 :

$$\begin{align}
52 \git 2 &= 26 && \text{reste } 0\\
26 \git 2 &= 13&& \text{reste } 0\\
13 \git 2 &= 6&& \text{reste } 1\\
6 \git 2 &= 3&& \text{reste } 0\\
3 \git 2 &= 1&& \text{reste } 1\\
1 \git 2 &= 0&& \text{reste } 1
\end{align}$$

On obtient donc $110100$ auquel on rajoute deux 0 ($00110100$). -52 étant négatif, on inverse les bits. Cela donne $11001011$ auquel on doit rajouter 1. La réponse est donc $11001100$

::: danger Attention
Si le dernier bit vaut déjà 1 (comme dans l'exemple précédent), il suffit de le changer en 0 et de se déplacer vers la gauche. On répète ce processus jusqu'à tomber sur un bit qui vaut 0. On le change alors en 1 et on s'arrête là.
:::

Pour -129, on se trouve en dehors de l'intervalle supportée. 8 bits ne seront donc pas suffisants pour représenter ce nombre. La réponse est donc `XXXXXXXX`.

## Question 3 - Decimal number representation (1/2)

### Solution

```
000100001101, 010000110110
```

### Explications

Pour les nombres à virgule, cela devient plus compliqué. La partie entière fonctionne de la même manière d'un entier (cf. les deux questions précédentes). Pour la partie décimale, on va appliquer la méthode décrite dans l'exemple ci-dessous.

Pour 33.6875, on commence par transformer 33 en binaire :

$$\begin{align}
33 \git 2 &= 16 && \text{reste } 1\\
16 \git 2 &= 8&& \text{reste } 0\\
8 \git 2 &= 4&& \text{reste } 0\\
4 \git 2 &= 2&& \text{reste } 0\\
2 \git 2 &= 1&& \text{reste } 0\\
1 \git 2 &= 0&& \text{reste } 1
\end{align}$$

On obtient $100001$. Pour la partie décimale, on va la multiplier par 2, noter la partie entière et recommencer le processus avec la partie décimale jusqu'à arriver à 1.

$$\begin{align}
0.6875 * 2 &= 1.375 && \text{on retient } 1\\
0.375 * 2 &= 0.75&& \text{on retient } 0\\
0.75 * 2 &= 1.5&& \text{on retient } 1\\
0.5 * 2 &= 1&& \text{on retient } 1
\end{align}$$

Pour avoir la réponse, il suffit de lire **du haut vers le bas** les différents chiffres retenus. La partie décimale s'écrira donc $1011$.

La consigne demande d'encoder tout cela sur 12 bits, avec un nombre précis de bits pour la partie décimale. Cela se fait facilement en rajoutant des 0 (à l'avant pour la partie entière et à l'arrière pour la partie décimale).
* Pour la première sous-question (3 bits), on a $12 - 3 = 9$ bits pour la partie entière : on rajoute donc trois 0 à l'avant, ce qui donne $000100001$. Pour la partie décimale, on a 3 bits de disponible alors que notre réponse a quatre chiffres. On va donc la tronquer, ce qui donne $101$. On colle les deux réponses bout à bout et on obtient $000100001101$.
* Pour la deuxième sous-question (5 bits), on a $12 - 5 = 7$ bits pour la partie entière : on rajoute donc un 0 à l'avant, ce qui donne $0100001$. Pour la partie décimale, on a 5 bits de disponibles alors que notre réponse a quatre chiffres. On va donc ajouter un 0 **à l'arrière**, ce qui donne $10110$. On colle les deux réponses bout à bout et on obtient $010000110110$.

## Question 4 - Decimal number representation (2/2)

### Solution

```
0100 0010 0000 0110 1100 0000 0000 0000
```

### Explications

## Question 5 - Relative error of fixed-point representation

### Solution

```
7
```

### Explications

## Question 6 - Order of operations

### Solution

```py:line-numbers
import numpy as np

def smart_sum(array):
    max_el = max(array)
    result = 0

    for i in array:
        if abs(i - max_el) < 1e-20: continue
        result += i 

    return result + max_el
```

### Explications