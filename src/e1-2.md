# E1.2 - Errors and error propagation

## Question 1 - Truncation errors for series

### Solution

```
11, 14, 1495
```

### Explications

Il suffit, comme l'explique l'indice, de faire un script Python pour chaque cas afin de calculer à partir de combien de terme la différence entre la valeur réelle et l'approximation passe en dessous de $10^{-10}$.

Pour $sin(x)$, on peut utiliser le code suivant :

```py
import numpy as np

def sin_series(x, n):
    result = 0
    sign = 1

    for i in range(1, 2 * n, 2):
        result += sign * (x ** i) / np.math.factorial(i)
        sign *= -1 # On inverse le signe

    return result

x = np.arange(-np.pi, np.pi + 0.01, 0.01) # Le deuxième argument est exclusif. On doit donc mettre np.pi + 0.1 pour être sur que pi soit dans le vecteur
n = 1

while not np.allclose(np.sin(x), np.vectorize(sin_series)(x, n), atol=1e-10, rtol=0):
    n += 1
        
print(f"Le n minimal est {n}.")
```

On obtient alors comme résultat que $N = 11$.

Pour $exp(x)$, on répète le même processus :

```py
import numpy as np

def exp_series(x, n):
    result = 0

    for i in range(n):
        result += (x ** i) / np.math.factorial(i)

    return result

x = np.arange(-1, 1 + 0.01, 0.01)
n = 1

while not np.allclose(np.vectorize(exp_series)(x, n), np.exp(x), atol=1e-10, rtol=0):
    n += 1
        
print(f"Le n minimal est {n}.")
```

On obtient alors comme résultat $N = 14$.

Encore la même chose avec $ln(x)$ :

```py
import numpy as np

def ln_series(x, n):
    result = 0
    sign = 1

    for i in range(1, n + 1):
        result += sign * (x ** i) / i
        sign *= -1 # On inverse le signe

    return result

x = np.arange(0, 0.99 + 0.01, 0.01)
n = 1

while not np.allclose(np.vectorize(ln_series)(x, n), np.log(1 + x), atol=1e-10, rtol=0):
    n += 1
        
print(f"Le n minimal est {n}.")
```

On obtient alors comme résultat $N = 1495$.

::: tip Précisions
Les fonctions [`np.allclose`](https://numpy.org/doc/stable/reference/generated/numpy.allclose.html) et [`np.vectorize`](https://numpy.org/doc/stable/reference/generated/numpy.vectorize.html) sont toutes les deux utilisées dans ces codes et sont très intéressantes. La première permet de vérifier si deux *arrays* ont tous leurs éléments égaux à une certaine tolérance près (définie par l'argument nommé `atol`. `rtol` quant à lui ne nous intéresse pas et doit donc être défini à 0, au risque de produire des résultats erronés). `np.sin` renvoie bien un *array*, mais ce n'est pas le cas pour la fonction `sin_series`. `np.vectorize` permet de réparer facilement le problème : elle prend un fonction `A` en argument et renvoie une autre fonction (que l'on appelle directement avec les arguments `x` et `n`) qui peut cette fois-ci prendre un *array* en argument et renvoyer un nouvel *array* dans lequel se trouveront tous les éléments auxquels on aura appliqué la fonction `A`. (Cela est équivalent à la fonction `map` d'une certaine manière)
:::

## Question 2 - Absolute and relative errors (1/4)

### Solution

```
0.0005, 0.05
```

### Explications

## Question 3 - Absolute and relative errors (2/4)

### Solution

```
0.001, 0.4
```

### Explications

## Question 4 - Absolute and relative errors (3/4)

### Solution

```
0.0111, 50
```

### Explications

## Question 5 - Absolute and relative errors (4/4)

### Solution

```py:line-numbers
import numpy as np
import matplotlib.pyplot as plt

x = np.arange(0.97, 1 - 2e-5, 2e-5)
f = np.sqrt(1 - x)
e = np.abs(-1 / (2 * np.sqrt(1 - x))) * 1e-3

plt.plot(x, f, 'r')
plt.plot(x, f + e, 'b')
plt.plot(x, f - e, 'g')

plt.xlabel('x')
plt.ylabel('f(x)')
plt.legend(['f(x)', 'f(x)+|e_f|', 'f(x)-|e_f|'])
plt.show()
```

### Explications

## Question 6

```py:line-numbers
import numpy as np

def error(x, y, z, e_x, e_y, e_z):
    return np.abs(y ** 2 * np.cos(x) - 1 + y * z) * np.abs(e_x) + np.abs(2 * y * np.sin(x) - z ** 3 / y ** 2 + x * z) * np.abs(e_y) + np.abs(3 * z ** 2 / y + x * y) * np.abs(e_z)
```

### Solution

### Explications

## Question 7 - Variance computation (1/2)

### Solution

$V_2 = \frac{1}{N} \sum_{i=1}^N (x_i - \mu)^2$

### Explications

## Question 8 - Variance computation (2/2)

### Solution

```py:line-numbers
import numpy as np

x = 10 ** 6.1 + np.arange(1, 8, dtype=np.float32)
V1 = np.mean(x**2)- np.mean(x) ** 2
V2 = np.mean((x - np.mean(x)) ** 2)
```

### Explications

## Question 9 - Operations errors

### Solution

```
100, 0
```

### Explications